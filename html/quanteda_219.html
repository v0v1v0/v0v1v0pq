<div class="container">

<table style="width: 100%;"><tr>
<td>pattern</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pattern for feature, token and keyword matching</h2>

<h3>Description</h3>

<p>Pattern(s) for use in matching features, tokens, and keywords through a
valuetype pattern.
</p>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>a character vector, list of character vectors, dictionary,
or collocations object.  See pattern for details.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The <code>pattern</code> argument is a vector of patterns, including
sequences, to match in a target object, whose match type is specified by
valuetype. Note that an empty pattern (<code>""</code>) will match
"padding" in a tokens object.
</p>

<dl>
<dt><code>character</code></dt>
<dd>
<p>A character vector of token patterns to be selected
or removed. Whitespace is not privileged, so that in a character vector,
white space is interpreted literally. If you wish to consider
whitespace-separated elements as sequences of tokens, wrap the argument in
<code>phrase()</code>. </p>
</dd>
<dt><code style="white-space: pre;">⁠list of character objects⁠</code></dt>
<dd>
<p>If the list elements are character
vectors of length 1, then this is equivalent to a vector of characters.  If
a list element contains a vector of characters longer than length 1, then
for matching will consider these as sequences of matches, equivalent to
wrapping the argument in <code>phrase()</code>, except for matching to
dfm features where this does not apply. </p>
</dd>
<dt><code>dictionary</code></dt>
<dd>
<p>Values in dictionary are used as patterns,
for literal matches. Multi-word values are automatically converted into
phrases, so performing selection or compounding using a dictionary is the
same as wrapping the dictionary in <code>phrase()</code>. </p>
</dd>
<dt><code>collocations</code></dt>
<dd>
<p>Collocations objects created from
<code>quanteda.textstats::textstat_collocations()</code>, which are treated as phrases
automatically.
</p>
</dd>
</dl>
<h3>See Also</h3>

<p>valuetype, case_insensitive
</p>


<h3>Examples</h3>

<pre><code class="language-R"># these are interpreted literally
(patt1 &lt;- c("president", "white house", "house of representatives"))
# as multi-word sequences
phrase(patt1)

# three single-word patterns
(patt2 &lt;- c("president", "white_house", "house_of_representatives"))
phrase(patt2)

# this is equivalent to phrase(patt1)
(patt3 &lt;- list(c("president"), c("white", "house"),
               c("house", "of", "representatives")))

# glob expression can be used
phrase(patt4 &lt;- c("president?", "white house", "house * representatives"))

# this is equivalent to phrase(patt4)
(patt5 &lt;- list(c("president?"), c("white", "house"), c("house", "*", "representatives")))

# dictionary with multi-word matches
(dict1 &lt;- dictionary(list(us = c("president", "white house", "house of representatives"))))
phrase(dict1)
</code></pre>


</div>