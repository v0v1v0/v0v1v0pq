<div class="container">

<table style="width: 100%;"><tr>
<td>quad.form</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Evaluate a quadratic form efficiently</h2>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><p>Given a square matrix \(M\) of size \(n\times n\), and a
matrix \(x\) of size \(n\times p\) (or a vector of length
\(n\)), evaluate various quadratic forms.
</p>
<p>The archetype is <code>quad.form(M,x)</code> for real or complex square
matrix <code>M</code> and vector or matrix <code>x</code>.  This evaluates
<code style="white-space: pre;">⁠Conj(t(x)) %*% M %*% x⁠</code> but using
<code>crossprod(crossprod(M,Conj(x)),x)</code> thus avoiding taking a
needless transpose.
</p>


<h3>Usage</h3>

<pre><code class="language-R">quad.form(M, x)
quad.form.inv(M, x)
quad.form.chol(chol,x)
quad.tform(M, x)
quad3.form(M,left,right)
quad3.tform(M,left,right)
quad.tform.inv(M,x)
quad.diag(M,x)
quad.tdiag(M,x)
quad3.diag(M,left,right)
quad3.tdiag(M,left,right)
cprod(x,y)
tcprod(x,y)
ht(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>Square matrix of size \(n\times n\)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x,y</code></td>
<td>
<p>Matrix of size \(n\times p\), or vector of length \(n\)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chol</code></td>
<td>
<p>Lower triangular Cholesky decomposition
of the quadratic form, see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>left,right</code></td>
<td>
<p>In function <code>quad3.form()</code>, matrices with
\(n\) rows and arbitrary number of columns</p>
</td>
</tr>
</table>
<h3>Details</h3>


<table>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>ht(x)</code>
</td>
<td style="text-align: left;">\(\mathbf{x}^{*}=\overline{\mathbf{x}^{\scriptscriptstyle T}}\)
  </td>
<td style="text-align: left;"><code>Conj(t(x))</code></td>
<td style="text-align: left;"><code>ht(x)</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>cprod(x,y)</code>
</td>
<td style="text-align: left;">\(\mathbf{x}^{*}\mathbf{y}\)
  </td>
<td style="text-align: left;"><code style="white-space: pre;">⁠ht(x) %*% y⁠</code></td>
<td style="text-align: left;"><code>cp()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>tcprod(x,y)</code>
</td>
<td style="text-align: left;">\(\mathbf{x}\mathbf{y}^{*}\)
  </td>
<td style="text-align: left;"><code style="white-space: pre;">⁠x %*% ht(y)⁠</code></td>
<td style="text-align: left;"><code>tcp()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad.form(M,x)</code>
</td>
<td style="text-align: left;">\(\mathbf{x}^{*}M\mathbf{x}\)
  </td>
<td style="text-align: left;"><code style="white-space: pre;">⁠ht(x) %*% M %*% x⁠</code></td>
<td style="text-align: left;"><code>qf()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad.form.inv(M,x)</code>
</td>
<td style="text-align: left;">\(\mathbf{x}^{*}M^{-1}\mathbf{x}\)
  </td>
<td style="text-align: left;"><code style="white-space: pre;">⁠ht(x) %*% solve(M) %*% x⁠</code></td>
<td style="text-align: left;"><code>qfi()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad.tform(M,x)</code>
</td>
<td style="text-align: left;">\(\mathbf{x}M\mathbf{x}^{*}\)
  </td>
<td style="text-align: left;"><code style="white-space: pre;">⁠x %*% A %*% ht(x)⁠</code></td>
<td style="text-align: left;"><code>qt()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad.tform.inv(M,x)</code>
</td>
<td style="text-align: left;">\(\mathbf{x}M^{-1}\mathbf{x}^{*}\)
  </td>
<td style="text-align: left;"><code style="white-space: pre;">⁠x %*% solve(M) %*% ht(x)⁠</code></td>
<td style="text-align: left;"><code>qti()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad3.form(M,l,r)</code>
</td>
<td style="text-align: left;">\(\mathbf{l}^{*}M\mathbf{r}\)
  </td>
<td style="text-align: left;"><code style="white-space: pre;">⁠t(l) %*% M %*% r⁠</code></td>
<td style="text-align: left;"><code>q3()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad3.form.inv(M,l,r)</code>
</td>
<td style="text-align: left;">\(\mathbf{l}^{*}M^{-1}\mathbf{r}\)
  </td>
<td style="text-align: left;"><code style="white-space: pre;">⁠t(l) %*% solve(M) %*% r⁠</code></td>
<td style="text-align: left;"><code>q3i()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad3.tform(M,l,r)</code>
</td>
<td style="text-align: left;">\(\mathbf{l}M\mathbf{r}^{*}\)
  </td>
<td style="text-align: left;"><code style="white-space: pre;">⁠l %*% M %*% t(r)⁠</code></td>
<td style="text-align: left;"><code>q3t()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad.diag(M,x)</code>
</td>
<td style="text-align: left;">\(\operatorname{diag}(\mathbf{x}^{*}M\mathbf{x})\)
  </td>
<td style="text-align: left;"><code style="white-space: pre;">⁠diag(quad.form(M,x))⁠</code></td>
<td style="text-align: left;"><code>qd()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad.tdiag(M,x)</code>
</td>
<td style="text-align: left;">\(\operatorname{diag}(\mathbf{x}M\mathbf{x}^{*})\)
  </td>
<td style="text-align: left;"><code style="white-space: pre;">⁠diag(quad.tform(M,x))⁠</code></td>
<td style="text-align: left;"><code>qtd()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad3.diag(M,l,r)</code>
</td>
<td style="text-align: left;">\(\operatorname{diag}(\mathbf{l}^{*}M\mathbf{r})\)
  </td>
<td style="text-align: left;"><code>diag(quad3.form(M,l,r))</code></td>
<td style="text-align: left;"><code>q3d()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad3.tdiag(M,l,r)</code>
</td>
<td style="text-align: left;">\(\operatorname{diag}(\mathbf{l}M\mathbf{r}^{*})\)
  </td>
<td style="text-align: left;"><code>diag(quad3.tform(M,l,r))</code></td>
<td style="text-align: left;"><code>q3td()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad.trace(M,x)</code>
</td>
<td style="text-align: left;">\(\operatorname{tr}(\mathbf{x}^{*}M\mathbf{x})\)
  </td>
<td style="text-align: left;"><code>tr(quad.form(M,x))</code></td>
<td style="text-align: left;"><code>qt()</code></td>
</tr>
<tr>
<td style="text-align: left;">
  <code>quad.ttrace(M,x)</code>
</td>
<td style="text-align: left;">\(\operatorname{tr}(\mathbf{x}M\mathbf{x}^{*})\)
  </td>
<td style="text-align: left;"><code>tr(quad.tform(M,x))</code></td>
<td style="text-align: left;">
<code>qtt()</code>
</td>
</tr>
</table>
<p><strong>In the above, \(\mathbf{x}^{*}\) denotes the
<em>complex conjugate</em> of the transpose, also known as the Hermitian
transpose</strong> (this only matters when considering complex numbers).
</p>
<p>These various functions generally avoid taking needless expensive
transposes in favour of using nested <code>crossprod()</code> and
<code>tcrossprod()</code> calls.  For example, the “meat” of
<code>quad.form()</code> is just <code>crossprod(crossprod(M,Conj(x)),x)</code>.
</p>
<p>Functions such as <code>quad.form.inv()</code> avoid taking a matrix
inverse.  The meat of <code>quad.form.inv()</code>, for example, is
<code>cprod(x, solve(M, x))</code>.  Many people have stated things like
“Never invert a matrix unless absolutely necessary”.  But I
have <em>never</em> seen a case where <code>quad.form.inv(M,x)</code> is
faster than <code>quad.form(solve(M),x)</code>.
</p>
<p>One motivation for the package is to return consistent results with
complex arguments.  Note, for example, that
<code>base::crossprod(x,y)</code> evaluates <code style="white-space: pre;">⁠t(x) %*% y⁠</code> and not, as
one would almost always want, <code style="white-space: pre;">⁠Conj(t(x)) %*% y⁠</code>.  Function
<code>cprod()</code>, unlike <code>crossprod()</code>, is consistent and returns
<code style="white-space: pre;">⁠Conj(t(x)) %*% y⁠</code> [or <code style="white-space: pre;">⁠ht(x) %*% y⁠</code>]; internally it is
essentially <code style="white-space: pre;">⁠crossprod(Conj(x), y)⁠</code>.
</p>
<p>Function <code>quad.form.chol()</code> interprets argument <code>chol</code> as
the lower triangular Cholesky decomposition of the quadratic form.
Remember that <code>M.lower %*% M.upper == M</code>, and <code>chol()</code>
returns the upper triangular matrix, so one needs to use the transpose
<code>t(chol(M))</code> in calls.  If the Cholesky decomposition of <code>M</code>
is available, then using <code>quad.form.chol()</code> and supplying
<code>chol(M)</code> should generally be faster (for large matrices) than
calling <code>quad.form()</code> and using <code>M</code> directly.  The time
saving is negligible for matrices smaller than about <i>50*50</i>, even if the overhead of computing the decomposition is
ignored.
</p>
<p>Functions <code>quad3.foo()</code> take three arguments: a matrix <code>M</code>
and two other vectors <code>l</code> and <code>r</code> [or <code>left</code> and
<code>right</code>].  For these functions, <code>M</code> is not necessarily
square although of course the matrices have to be compatible.
</p>
<p>Functions <code>quad3.form_ab()</code> and <code>quad3.form_bc()</code> are helper
functions not really intended for the end-user.  They return
mathematically identical results but differ in the bracketing order of
their operations: <code>quad3.form_ab(M,l,r)</code> returns
\(\left(\mathbf{l}^*M\right)\mathbf{r}\) and
<code>quad3.form_bc(M,l,r)</code> returns
\(\mathbf{l}^{*}\left(M\mathbf{r}\right)\).  The mnemonic
for their names is derived from the first multiplication when
calculating \((ab)c\) and \(a(bc)\).  Note that
<code>quad3.form_ab(M,l,r)</code> returns
<code style="white-space: pre;">⁠crossprod(crossprod(M,Conj(l)),r)⁠</code> rather than the
mathematically equivalent <code style="white-space: pre;">⁠cprod(cprod(M,l),r)⁠</code> on efficiency
grounds (only a single conjugate is taken).
</p>
<p>Function <code>quad3.form()</code> dispatches to either
<code>quad3.form_ab()</code> or <code>quad3.form_bc()</code> depending on the
dimensions of its argument as per the efficiency discussion at
<code>inst/quadform3test.Rmd</code>.  Similar considerations apply to
<code>quad3.tform()</code>, <code>quad3.tform_ab()</code>, and
<code>quad3.tform_bc()</code>.
</p>
<p>Terse forms [<code>qf()</code> for <code>quad.form()</code>, <code>qti()</code> for
<code>quad.tform.inv()</code>, etc] are provided for the perl
golfers among us.
</p>


<h3>Value</h3>

<p>Generally, return a (dropped) matrix, real or complex as appropriate
</p>


<h3>Note</h3>

<p>These functions are used extensively in the <a href="https://CRAN.R-project.org/package=emulator"><span class="pkg">emulator</span></a> and
<a href="https://CRAN.R-project.org/package=calibrator"><span class="pkg">calibrator</span></a> packages, primarily in the interests of elegant
code, but also speed.  For the problems I usually consider, the speedup
(of <code>quad.form(M,x)</code> over <code style="white-space: pre;">⁠t(x) %*% M %*% x⁠</code>, say) is
marginal at best.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class="language-R">jj &lt;- matrix(rnorm(80),20,4)
M &lt;- crossprod(jj,jj)
M.lower &lt;- t(chol(M))
x &lt;- matrix(rnorm(8),4,2)

jj.1 &lt;- t(x) %*% M %*% x
jj.2 &lt;- quad.form(M,x)
jj.3 &lt;- quad.form.chol(M.lower, x)
print(jj.1)
print(jj.2)
print(jj.3)


## Make two Hermitian positive-definite matrices:
L &lt;- matrix(c(1,0.1i,-0.1i,1),2,2)
LL &lt;- diag(11)
LL[2,1] &lt;- -(LL[1,2] &lt;- 0.1i)

z &lt;- matrix(rnorm(22) + 1i*rnorm(22),2,11)

quad.diag(L,z)     # elements real because L is HPD
quad.tdiag(LL,z)   # ditto


## Now consider accuracy:
quad.form(solve(M),x) - quad.form.inv(M,x)  # should be zero
quad.form(M,x) - quad.tform(M,t(x))         # should be zero
quad.diag(M,x) - diag(quad.form(M,x))       # should be zero
diag(quad.form(L,z))   - quad.diag(L,z)     # should be zero
diag(quad.tform(LL,z)) - quad.tdiag(LL,z)   # should be zero
</code></pre>


</div>