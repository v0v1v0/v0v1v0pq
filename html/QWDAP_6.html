<div class="container">

<table style="width: 100%;"><tr>
<td>qwdap.qwalk</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Quantum Walk</h2>

<h3>Description</h3>

<p>Generate the modes, the probabilities that the walker being found at vertices.
An adjacency matrix is need for the process.
</p>


<h3>Usage</h3>

<pre><code class="language-R">qwdap.qwalk(edges, startindex, lens, scals, getfloat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>edges</code></td>
<td>
<p>your N*N adjacency matrix saved as list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startindex</code></td>
<td>
<p>the initial position of the quantum walker.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lens</code></td>
<td>
<p>the number of records required in a round of sampling by a scaling factor.
Set the length of the series according to requirements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scals</code></td>
<td>
<p>the scaling factors used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>getfloat</code></td>
<td>
<p>Whether to return floating point data.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>'qwdap.qwalk()' is used to generated modes for time series analysis, the result is a object
of class 'CTQW', the modes are saved in the object as a 3-dim array, and the parameters are also
store in the object.
The continuous time quantum walk is a continuous process, the modes are generated with a series
of times, the parameter 'scals' can be understood as the tolerance of the arithmetic time series.
Multiply tolerances can be passed in to obtain modes on different time scales through parameter
'scals'.
The probability of the series with the probabilities that the walker being found at the vertices, 
and the length depends on parameter 'lens'.
The data generated by this function is not recorded from the initial state. 
The shortest distance between all vertices and the initial position of the quantum walker is
obtained by the Dijkstra algorithm.The probabilities corresponding to each vertex are
recorded starting from the vertex furthest in the shortest distance is not 0.
The function is single thread.
</p>


<h3>Value</h3>

<p>a object of class 'CTQW', the quantum walk results and some parameters.
</p>


<h3>Author(s)</h3>

<p>Pan Binghuang
</p>


<h3>Examples</h3>

<pre><code class="language-R">edges &lt;- matrix(c(0,1,0,0,0,0,0,
                  1,0,1,0,0,0,0,
                  0,1,0,1,0,0,0,
                  0,0,1,0,1,0,0,
                  0,0,0,1,0,1,0,
                  0,0,0,0,1,0,1,
                  0,0,0,0,0,1,0),
                nrow = 7)
res.qwalk &lt;- qwdap.qwalk(edges,1,100,scals=seq(from=0.01, by=0.01, length.out=5))

</code></pre>


</div>