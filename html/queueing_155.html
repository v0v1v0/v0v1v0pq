<div class="container">

<table style="width: 100%;"><tr>
<td>queueing-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Analysis of Queueing Networks and Models.
</h2>

<h3>Description</h3>

<p>It provides a versatile tool for analysis of birth and death based Markovian Queueing Models and Single and Multiclass Product-Form Queueing Networks.<br><br>
It implements the following basic markovian models:<br><br></p>

<table>
<tr>
<td style="text-align: left;">
M/M/1, </td>
<td style="text-align: left;"> M/M/c, </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> M/M/Infinite,</td>
</tr>
<tr>
<td style="text-align: left;">
M/M/1/K, </td>
<td style="text-align: left;"> M/M/c/K, </td>
<td style="text-align: left;"> M/M/c/c, </td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
M/M/1/K/K, </td>
<td style="text-align: left;"> M/M/c/K/K, </td>
<td style="text-align: left;"> M/M/c/K/m, </td>
<td style="text-align: left;"> M/M/Infinite/K/K</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>It also solves the following types of networks:<br></p>

<ul>
<li>
<p> Multiple Channel Open Jackson Networks.
</p>
</li>
<li>
<p> Multiple Channel Closed Jackson Networks.
</p>
</li>
<li>
<p> Single Channel Multiple Class Open Networks.
</p>
</li>
<li>
<p> Single Channel Multiple Class Closed Networks
</p>
</li>
<li>
<p> Single Channel Multiple Class Mixed Networks 
</p>
</li>
</ul>
<p>Also it provides B-Erlang, C-Erlang and Engset calculators.<br></p>
<p>This work is dedicated to the memory of D. Sixto Rios Insua.
</p>


<h3>Details</h3>

<p>All models are used in the same way:<br></p>

<ol>
<li>
<p> Create inputs calling the appropiate <em>NewInput.model</em>. For example, <code>x &lt;- NewInput.MM1(lambda=0.25, mu=1, n=10)</code> for a M/M/1 model. To know the exact acronymn model to use for <em>NewInput</em> function, you can search the html help or write <code>help.search("NewInput")</code> at the command line.
</p>
</li>
<li>
<p> Optionally, as a help for creating the inputs, the <code>CheckInput(x)</code> function can be called
</p>
</li>
<li>
<p> Solve the model calling <code>y &lt;- QueueingModel(x)</code>. In this step, the <code>CheckInput(x)</code> will be called. That is the reason that the previous step is optional
</p>
</li>
<li>
<p> Finally, you can get a performance value as <code>W(y)</code>, <code>Wq(y)</code> or a report of the principals performace values calling <code>summary(y)</code>
</p>
</li>
</ol>
<p>See the examples for more detailed information of the use.
</p>


<h3>Author(s)</h3>

<p>Author, Maintainer and Copyright: Pedro Canadilla <a href="mailto:pedro.canadilla@gmail.com">pedro.canadilla@gmail.com</a>
</p>


<h3>References</h3>

<p>[Sixto2004] Sixto Rios Insua, Alfonso Mateos Caballero, M Concepcion Bielza Lozoya, Antonio Jimenez Martin (2004).<br><em>Investigacion Operativa. Modelos deterministicos y estocasticos</em>.<br>
Editorial Centro de Estudios Ramon Areces.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## M/M/1 model
summary(QueueingModel(NewInput.MM1(lambda=1/4, mu=1/3, n=0)))

## M/M/1/K model
summary(QueueingModel(NewInput.MM1K(lambda=1/4, mu=1/3, k=3)))

</code></pre>


</div>