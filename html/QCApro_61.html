<div class="container">

<table style="width: 100%;"><tr>
<td>submodels</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute All Correctness-Preserving Submodels of a QCA Reference Model</h2>

<h3>Description</h3>

<p>This evaluation function computes all correctness-preserving submodels of a QCA reference 
model. It has initially been programmed for <a href="https://www.researchgate.net/publication/280555425_Often_Trusted_But_Never_Properly_Tested_Evaluating_Qualitative_Comparative_Analysis">Baumgartner and Thiem (2015)</a> to test 
the correctness of QCA's three search strategies (conservative/complex, intermediate, 
parsimonious).
</p>


<h3>Usage</h3>

<pre><code class="language-R">submodels(expression, noflevels = c(), test = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expression</code></td>
<td>
<p>A string representing a csQCA or an fsQCA model, or a csQCA 
or fsQCA solution object of class 'qca' (created by the 
<code>eQMC</code> function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noflevels</code></td>
<td>
<p>A numeric vector specifying the number of levels for each
factor (experimental, can be ignored).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>Logical, test whether <code>expression</code> is a causal structure.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function has initially been programmed for <a href="https://www.researchgate.net/publication/280555425_Often_Trusted_But_Never_Properly_Tested_Evaluating_Qualitative_Comparative_Analysis">Baumgartner and Thiem (2015)</a> to 
test the correctness of QCA's three solution types (conservative/complex, 
intermediate, parsimonious). It computes all submodels of a csQCA or an fsQCA 
reference model that do not violate the criterion of correctness (mvQCA models 
are not yet supported). The following expression structures can be used: 
<code>"A*B + C*D &lt;=&gt; Y"</code> or <code>"AB + CD &lt;=&gt; Y"</code>. Empty spaces and the type 
of conditional operator (<code>&lt;-&gt;</code>/<code>&lt;=&gt;</code>/<code>-&gt;</code>/<code>=&gt;</code>) are irrelevant,
but only single letters are allowed for exogenous factors. The full model need not 
be provided; the antecedent also suffices (e.g., <code>"AB + CD"</code>). 
</p>
<p>Objects of class 'qca', which are returned by the <code>eQMC</code> function, 
are also accepted, provided that all exogenous factors have a single-letter label 
(set the argument <code>use.letters</code> to <code>TRUE</code> in the function call to 
<code>eQMC</code> if original factor labels are not single letters). 
</p>
<p>The argument <code>noflevels</code> expects a numeric vector of the number of factor
levels with a <code>names</code> attribute. Currently, this argument is experimental
and can be ignored.
</p>
<p>The argument <code>test</code> specifies whether <code>expression</code> should be pre-tested 
for its causal interpretability before forming submodels. The value to this argument 
does not affect whether basic tests for likely typos in expressions such as 
<code>"abb &lt;-&gt; C"</code> or <code>"abB &lt;-&gt; C"</code> are performed. If <code>expression</code> is 
an object of class 'qca', <code>test</code> will be set to <code>FALSE</code> because QCA 
models generated by the <code>eQMC</code> function at default argument settings are 
always causally interpretable.
</p>
<p>Note that for highly complex models containing many conjuncts within many 
disjuncts, computing times tend to increase considerably.
</p>


<h3>Value</h3>

<p>A list with the following four main components:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>The reference model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noflevels</code></td>
<td>
<p>The number of levels for each factor in the factor frame 
of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outcome</code></td>
<td>
<p>The outcome specified as part of the expression or a pseudo
outcome if only an antecedent was specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>submodels</code></td>
<td>
<p>A character vector of all correctness-preserving submodels.</p>
</td>
</tr>
</table>
<h3>Contributors (alphabetical)</h3>


<table>
<tr>
<td style="text-align: left;">
Baumgartner, Michael</td>
<td style="text-align: left;">: development, testing</td>
</tr>
<tr>
<td style="text-align: left;">
Thiem, Alrik        </td>
<td style="text-align: left;">: development, documentation, programming, testing
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Alrik Thiem (<a href="http://www.alrik-thiem.net">Personal Website</a>; <a href="https://www.researchgate.net/profile/Alrik_Thiem">ResearchGate Website</a>)
</p>


<h3>References</h3>

<p>Baumgartner, Michael, and Alrik Thiem. 2015. <em>Often Trusted but Never 
(Properly) Tested: Evaluating Qualitative Comparative Analysis</em>. Paper presented 
at the 12th Conference of the European Sociological Association, 25-28 August, 
Czech Technical University, Prague (Czech Republic). <a href="https://www.researchgate.net/publication/280555425_Often_Trusted_But_Never_Properly_Tested_Evaluating_Qualitative_Comparative_Analysis">Link</a>.
</p>


<h3>See Also</h3>

<p><code>eQMC</code>, <code>limitedDiversity</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# provide a) a full model as an equivalence and inspect its submodels
models1 &lt;- submodels("a*B + B*c + D &lt;-&gt; Z") 
models1$submodels

# ... b) a full model with a negated outcome
# submodels
models2 &lt;- submodels("AcD + BCD + abcd &lt;=&gt; e")
length(models2$submodels)

# ... c) or only an antecedent
models3 &lt;- submodels("aB + Bc + D")
models3$submodels

# directly provide an object of class 'qca' generated by the 'eQMC' function,
# even when the solution comprises multiple models; specify 
# 'use.letters = TRUE' when the original exogenous factors have multi-letter 
# labels; for example:
data(d.represent)
sol1 &lt;- eQMC(d.represent, outcome = "WNP", neg.out = TRUE, use.letters = TRUE)
sol1
# M1: ae + cde + (bdE) &lt;=&gt; wnp 
# M2: ae + cde + (bcd) &lt;=&gt; wnp 
# M3: ae + cde + (Abc) &lt;=&gt; wnp
# M1 has 138 submodels, M2 has 129, and M3 has 139 submodels
models4 &lt;- submodels(sol1)
sapply(models4, "[")

# when original labels of exogenous factors already consist of single 
# letters only, 'use.letters = TRUE' need not be specified
data(d.napoleon)
sol2 &lt;- eQMC(d.napoleon, outcome = "O")
sol2
models5 &lt;- submodels(sol2)
sapply(models5, "[")

# prior testing is recommended because non-causal models can sometimes only
# be identified computationally
submodels("aB + Ac + Ad + bc + bd + CD")

# can a + AbC =&gt; Y be an acceptable QCA solution as Schneider and Wagemann 
# (2012, p. 108) argue? No, because in Boolean algebra, it holds that
# F + fG = (F + f) * (F + G) = 1*(F + G) = F + G by the laws of distribution,
# complementarity, and identity
submodels("a + AbC =&gt; Y", test = TRUE)

# proof that the conservative/complex solution type of QCA is incorrect, 
# using model 3 from above (see Baumgartner and Thiem (2015) for more details)

# 1. build saturated truth table on the basis of model 3: aB + Bc + D
tt &lt;- data.frame(mintermMatrix(rep(2, 5)))
dimnames(tt) &lt;- list(as.character(1:32), c(LETTERS[1:4], "OUT"))
tt &lt;- tt[pmax(pmin(1 - tt$A, tt$B), pmin(tt$B, 1 - tt$C), tt$D) == tt$OUT, ]

# 2. use function 'limitedDiversity' to generate all conservative/complex
# solutions for all 16 + 120 scenarios of one/two dropped minterm/s
sollist.cs &lt;- vector("list", 2)
sollist.cs &lt;- lapply(1:2, function (x) {
  limitedDiversity(tt, outcome = "OUT", sol.type = "cs", n.drop = x)
  }
)

# 3. compute in how many scenarios a correctness-preserving submodel of 
# model 3 was part of the solution (43.75% for one dropped minterm and 
# 16.67% for two dropped minterms)
cs.correct &lt;- numeric(2)
cs.correct &lt;- sapply(1:2, function (x) {round((sum(unlist(lapply(
  sollist.cs[[x]][[2]], function (y) {any(models3$submodels %in% y)}
  ))) / choose(16, x))*100, 2)}
)
cs.correct

## End(Not run)
</code></pre>


</div>