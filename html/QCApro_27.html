<div class="container">

<table style="width: 100%;"><tr>
<td>factorize</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Factorize Configurational Expressions</h2>

<h3>Description</h3>

<p>This function finds all possibilities for factorizing a configurational expression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">factorize(expression, and.split = "", sort.factorizing = FALSE, 
          sort.factorized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expression</code></td>
<td>
<p>A string representing a configurational expression or a QCA
solution object of class “qca” generated by <code>eQMC()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>and.split</code></td>
<td>
<p>The AND-operator (if any).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort.factorizing</code></td>
<td>
<p>Logical, sort results beginning with largest number of 
factorizing elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort.factorized</code></td>
<td>
<p>Logical, sort results beginning with largest number of 
factorized elements.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In Boolean algebra, the “*”-operator is distributive over the “+”- 
operator such that for any three literals <code class="reqn">a</code>, <code class="reqn">b</code> and <code class="reqn">c</code>, the 
following law holds: <code class="reqn">(a*b) + (a*c) = a*(b + c)</code> 
(Hohn 1966, pp.78-80; South 1974, p.12). The '<code>factorize</code>' function finds 
all possible <code class="reqn">a</code> for any configurational expression. Factorized versions 
of the initial expression(s) can be sorted in decreasing order by the number of 
factorizing literals or in decreasing order by the number of factorized literals. 
</p>


<h3>Value</h3>

<p>A list with the following components:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>The initial expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factored</code></td>
<td>
<p>The factorizations of the initial expression.</p>
</td>
</tr>
</table>
<h3>Contributors</h3>


<table>
<tr>
<td style="text-align: left;">
Dusa, Adrian</td>
<td style="text-align: left;">: development, programming, testing</td>
</tr>
<tr>
<td style="text-align: left;">
Thiem, Alrik</td>
<td style="text-align: left;">: development, documentation, testing
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Alrik Thiem (<a href="http://www.alrik-thiem.net">Personal Website</a>; <a href="https://www.researchgate.net/profile/Alrik_Thiem">ResearchGate Website</a>)
</p>


<h3>References</h3>

<p>Hohn, Franz E. 1966. <em>Applied Boolean Algebra: An Elementary Introduction</em>. 
2nd ed. New York: Macmillan.
</p>
<p>South, G. F. 1974. <em>Boolean Algebra and Its Uses</em>. New York: Van Nostrand Reinhold.
</p>


<h3>See Also</h3>

<p><code>eQMC</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># factorize a disjunction of two two-way conjunctions;
# if single letters are used, argument "and.split" is not needed
factorize("AB + AC")

# "and.split" is needed in these cases
factorize("one*TWO*four + one*THREE + THREE*four", and.split = "*")
factorize("~ONE*TWO*~FOUR + ~ONE*THREE + THREE*~FOUR", and.split = "*")
factorize("one&amp;TWO&amp;four + one&amp;THREE + THREE&amp;four", and.split = "&amp;")

# factorize solution objects directly
data(d.represent)
KRO.sol &lt;- eQMC(d.represent, outcome = "WNP")
factorize(KRO.sol)
</code></pre>


</div>